<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script src="./index.js"></script>
    <div class="box">
        <h1>基础类型</h1>
        <dl>
            <dt>介绍</dt>
            <dd>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。TypeScript支持与javscript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用</dd>
        </dl>
        <dl>
            <dt>
                <h2>布尔值</h2>
            </dt>
            <dd>最基本的数据类型就是简单的true/false值，在jascript和TypeScript里 叫做boolean</dd>
            <dd>
                <code>
                    <p>
                        let isDone: boolean = false
                    </p>
                </code>
            </dd>
        </dl>
        <dl>
            <dt>
                <h2>数字</h2>
            </dt>
            <dd>
                和javscrript一样，TypeScript里的所有数字都是浮点数，这些浮点的类型是number，除了支持十进制和十六进制字面量，Typescript还支持ECMAScript2015中引入的二进制和八进制字面量
            </dd>
            <dd>
                <code>
                    <p>
                        let decLiteral: number = 7;
                    </p>
                    <p>
                        let hexLiteral: number = 0xf00d;
                    </p>
                    <p>
                        let binaryLiteral: number = 0b1010;
                    </p>
                    <p>
                        let octalLiteral: number = 0o744;
                    </p>
                </code>
            </dd>
        </dl>
        <!-- end -->
        <dl>
            <dt>
                <h2>字符串</h2>
            </dt>
            <dd>
                jsvascript程序的另一项基本操作就是处理网页或服务器 的文本数据，我们使用string表示文本数据类型，和javascrpt一样，可以使用双引号或单引号表示字符串
            </dd>
            <dd>
                <code>
                    <p>
                        let name: string = 'xu'
                            name = 'li'
                    </p>
                    <p>
                        还可以使用模板字符串，她可以定义多行文本和内嵌表达式，这种字符串被反引号包围(`),并且以${expr}这种形式嵌入表达式
                    </p>
                    <p>
                        let name: string = `xu`
                        let num: number = 11
                        let sentence: string = `Hello,My name is ${name}, I'ii be ${num} years old next month`
                    </p>
                </code>
            </dd>
        </dl>
        <!-- end -->
        <dl>
            <dt>
                <h2>数组</h2>
            </dt>
            <dd>
                typescript像javascript一样可以操作数组元素。有两种方式可以定义数组，第一种，可以在元素类型后面接上[]，表示此类型元素组成一个数组
            </dd>
            <dd>
                <code>
                    <p>
                        第一种，可以在元素类型后面接上[]，表示此类型元素组成一个数组
                        let list:number[] = [1,2,3] 数组内容只能是number类型
                    </p>
                    <p>
                        第二种方式是使用数组泛型 Array<元素类型> <br />
                        let list:Array<number> = [1,2,3]
                    </p>
                </code>
            </dd>
        </dl>
        <dl>
            <dt>
                <h2>元组 Tuple</h2>
            </dt>
            <dd>
                元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型的不必相同。比如,你可以定义一对值分别为string和number类型的元组
            </dd>
            <dd>
                <code>
                    let x: [string,number]
                    x = ['hello',123] // OK

                    x = [123, 'hello'] // Error
                </code>
            </dd>

            <dd>
                <p>当访问一个已知索引的元素,会得到正确的类型</p>
                <code>
                    x[0].substr(1) // Ok
                    x[1].subser(1) // Error 'number' does not have 'substr'
                </code>
            </dd>
            <dd>
                <p>当访问一个越界的元素，会使用联合类型替代</p>
                <code>
                    x[3] = 'world' // OK 字符串可以赋值给(string|number) 类型
                    console.log(x[5].toString()) // OK 'string ' 和 ' number' 都有toString

                    x[6] = true // Error 布尔不是(string | number) 类型
                </code>
            </dd>
        </dl>
        <dl>
            <dt>
                <h2>枚举</h2>
            </dt>
            <dd>enum 类型是对Javascript 标准数据类型的一个补充。像C#等 其他预言一样，使用枚举类型可以为一组数值赋予友好的名字</dd>
            <dd>
                <code>
                    enum Color {Red,Green,Blue}
                    let c:Color = Color.Red
                </code>
            </dd>
            <dd>默认情况下，从0开始为元素编号，你也可以手动的指定成员的数值，列如，我们将列子改成1开始编号</dd>
            <dd>
                <code>
                    enum Color {Red = 1, Green,Blue}
                    let Color: Color = Color[1]
                    console.log(Red) 
                </code>
            </dd>
        </dl>
        <dl>
            <dt><h3>Any</h3></dt>
            <dd>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来自动态的内容。比如来自用户输入或第三放的代码库。这种情况下，我们不希望类型检查对这些值对其进行检查，我们可以使用any类型来标记这些变量</dd>
            <dd>
                <code>
                    let color:any = 4
                    let str:any =true
                    str = 'str'
                    str = null
                </code>
            </dd>
            <dd>
                <p>
                    在对现有代码进行改写的时候，any 十分有用，他允许你编译时可选择的包含或移除类型检查。你可能认为Object有相似的作用，就像他在其他语言中那样，
                    <br />
                    但是Object类型的变量只是运行你给他赋予任意的值，但是却不能在上面调用任意的方法，即便他时真的有这些方法
                </p>
            </dd>
            <dd>
                <P>
                    <code>
                        let number: any = 3
                        number.toFixed(2)


                        let objType:Object = 3
                        objType.toFixed(2) // Error
                    </code>
                </P>
            </dd>
            <dd>
                <p>
                    当你只知道一部分数据类型时， any类型也是有用的
                </p>
            </dd>
            <dd>
                <p>
                    <code>
                        let list: any = [23,'eqw',true]

                    </code>
                </p>
            </dd>
        </dl>
        <dl>
            <dt>
                <h3>Void</h3>
            </dt>
            <dd>某种程度上来说，void类型像是与any类型相反，他表示没有任何类型，当一个函数没有返回值时，你通常会见到其返回类型是void</dd>
            <dd>
                <p>
                    <code>
                        function warnUser():void{
                            console.log(warnUser)
                        }
                    </code>
                </p>
            </dd>
            <dd>
                <p>声明一个void类型的变量没有什么大用，因为你只能赋予undefined和null</p>
            </dd>
            <dd>
                <p>
                    <code>
                        let unusable:void = uindefined
                    </code>
                </p>
            </dd>
        </dl>
        <dl>
            <dt>
                <h3>
                    null  和 undefined
                </h3>
                <p>
                    TypeScript里undefined和Null两者各自有自己的类型，和void类似，他们本身的类型用处不是很大
                </p>
            </dt>
            <dd>
                <code>
                    let u:undefined = undefined
                    let n:null = null
                </code>
            </dd>
            <dd>
                <p>
                    默认情况下null和undefined是所有类型的子类型，就是说你可以把null和undefined赋值给number的变量
                    <br />
                    然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 再次说明，稍后我们会介绍联合类型。
                    <br />
                    注意：我们鼓励尽可能地使用--strictNullChecks，但在本手册里我们假设这个标记是关闭的。
                </p>
                
            </dd>
        </dl>
        <dl>
            <dt>
                <h3>Never</h3>
                <p>
                    Never 类型表示的类型是那些永不存在的类型。列如，never类型是那些总会抛出异常或根本不会有返回值的函数或箭头函数表达式的返回值类型，变量也可能是never类型，当他们被永不为真的类型保护所约束时
                </p>
            </dt>
            <dd>
                <p>
                    never 类型是任何类型的子类型， 也可以赋值给任何类型，然而，没有类型是never的子类型或可以赋值给never类型(除never本身之外)  即使any 也不可以赋值never
                </p>
            </dd>
            <dd>
                <p>返回never 的函数必须存在无法达到的终点</p>
                <p>
                    <code>
                        function error(message:string) :never{
                            throw new Error(message)
                        }
                    </code>
                </p>
                <p>推断的返回值为never</p>
                <p>
                    <code>
                        function fail() :never{
                            return error('Something failed')
                        }
                    </code>
                </p>
                <p>// 返回never的函数必须存在无法达到的终点</p>
                <p> 
                    <code>
                        function infiniteLoop() :never {
                            while(true){
    
                            }
                        }
                    </code>
                    
                </p>
            </dd>
        </dl>
        <dl>
            <dt>
                <h3>Object</h3>
                <p>object 表示非原始类型，也就是出number/streing/boolean/symbol/undefined/null， 之外的类型</p>
            </dt>
            <dd>
                <p>
                    使用object 类型就可以更好的表示Object.create这样的API
                </p>
            </dd>
            <dd>
                <p>
                    <code>
                        declare function create(o:object|null):void

                        create({ prop: 0 }); // OK
                        create(null); // OK

                        create(42); // Error
                        create("string"); // Error
                        create(false); // Error
                        create(undefined); // Error
                    </code>
                </p>
            </dd>
        </dl>
        <dl>
            <dt>
                 <h3>
                     类型断言
                 </h3>
                 <p>
                     有时候你会遇到这样的情况，你会比TypeScript更了解某个值的信息，通常这会发生在你清楚的知道一个实体具有比他现有类型更确切的类型
                 </p>
            </dt>
            <dd>
                <p>
                    通过类型断言这种方式可以告诉编译器， 相信我， 我知道自己在干什么， 类型断言就好比其他语言里的类型转换， 但是不进行特殊的数据检查和解构， 他没有运行时的影响， 只是在编译起作用，TS会假设你已经进行了必须的检查 
                </p>
            </dd>
            <dd>
                <p>类型断言有两种形式。 第一种是 尖括号语法</p>
                <p>
                    <code>
                        let someValue:any = this is a bundleRenderer.renderToString
                        let strLength:number = (<string> someValue).length
                    </code>
                </p>
                <p>第二种 as 语法</p>
                <p>
                    <code>
                        let someValue :any = 'this is a string'

                        let someLength:number = (someValue as string).length
                    </code>
                </p>
            </dd>
            <dd>
                    两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。
            </dd>
        </dl>
    </div>
</body>
</html>